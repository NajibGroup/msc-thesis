% !TEX root = ../main.tex
\chapter{Overview of the Approach}
\label{chap:overview-of-the-approach}

In this chapter I introduce the high level architecture overview of the proposed framework. Also look at the components one-by-one and discuss how they cooperate, in detail.

\section{Architecture}
\label{sect:architecture}
\Cref{fig:architecture-overview} shows the overview of the framework's architecture. Since the novelty of the approach is how the source code representation is handled --- stored, transformed, and queried --- the heart of the approach is visualized on the right half of the figure. This is embedded and utilized in the framework itself, and integrated into the continuous integration circle and user-facing systems.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\textwidth]{architecture-PPT.pdf}
  \caption{Architecture Overview of the Approach}
  \label{fig:architecture-overview}
\end{figure}


\section{Main Components}

\subsection{Workflow Integration Points}
The framework is intented to be integrated with at least two types of workflow components. First, connecting to the \emph{Version Control System} makes it possible to extend the continuous integration workflow and provide the users of the system with current information about the codebase they are working on. Second, connecting to the \emph{Integrated Development Environment} of every user empowers them with proactive feedback on their modifications.

\subsubsection{Version Control System (VCS)}
Version control systems are file change (e.g. documents, software code, etc.) management systems. They store revisions of the current set of files managed by the system. Each revision is differentiated with a timestamp, and a person performing the changes are also associated with a revision.

Version control is one of the most essential collaboration tool. When developers work on the same codebase, especially when the codebase is large, they need to share the code and work on it at the same time. Using a VCS, one can investigate the current version of the codebase at a selected revision. Also, it is possible to determine the changes made between two revisions, manage multiple development branches with the same root and merge the changes made in these.

Integrating a VCS into the architecture makes it possible to extend the workflow with the features of the framework. By automatically calculating the changeset and forwarding this information to the framework, it is possible to keep an up-to-date representation of the version controlled data source.

The most known implementations are Git~\cite{git}, Subversion (SVN)~\cite{svn}, Mercurial (Hg)~\cite{hg}.

\subsubsection{Integrated Development Environment (IDE)}
An IDE is an application for (software) developers that integrate several tools making it easier to write, compile, and test the product. Integrated development environments are detailed in \Cref{sect:IDE}.

In the architectural overview, the IDE also represents the working set of the software and its dependencies available on the developer's computer. This working set also contains the developer's modifications that are not yet transferred to the shared VCS.


\subsection{Transforming the Source Code}
One of the most important third party components of the approach is the source code parser. This component is used to transform a given source file, a \emph{compilation unit} into a model representation of the syntax and semantics of the source code. The process itself is detailed in~\Cref{sect:source-code-processing}.

A source code parsing toolkit with the following traits make it possible to integrate it into the framework with ease:

\begin{itemize}[topsep=0pt]
  \item Provide the Abstract Syntax Tree and Abstract Semantic Graph for the parsed source file.

  \item Also provide scoping information
  % TODO

  \item Source code position
  % TODO

  \item Metamodel for the representation
  The more detailed metamodel, the better.
\end{itemize}

Since the \emph{Shape Security Shift} toolkit (detailed in~\Cref{sect:shift}) suits these requirements well, I've used the Java implementation of the \emph{Shift Parser}, and \emph{Scope Analyzer}.


\subsection{Graph Maintenance}
The novelty of my approach is how it processes, stores and connects the source code representation in a graph database. In this section I'll discuss how the subgraphs of the source code files are prepared and then connected to each other constructing a connected graph representing the whole source code repository.

The whole process can be summarized in 4 concise sentences:
\begin{enumerate}[topsep=0pt]
  \item The repository is transformed one file at a time.
  \item The ASG \emph{model} is transformed into a \emph{property graph}.
  \item After every file is processed, the ASG subgraphs are interconnected using graph transformations.
  \item In case a file is added/modified/deleted, the corresponding subgraph is also added/removed and reprocessed/removed from the graph.
\end{enumerate}

\subsubsection{Transforming the Instance Model}


\subsubsection{Storing the Graph Representation}
\subsubsection{Transforming the Graph}
\subsubsection{Multilayered Graph}

\section{Steps of Processing}
\subsection{Initial State}
\subsection{Calculating the Change to Propagate}
\subsection{Maintaining the Graph}
\subsubsection{Determining and Executing the Changes}
\subsubsection{Building Interconnections}
\subsection{Executing Graph Queries}

\section{Dead Code Search}

\section{Control Flow Graph}

\section{Language Limitations}
